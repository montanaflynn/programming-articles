---
author: Swizec Teller
source: https://github.com/Swizec/nightowls
---

Ayrton Senna's experience during a qualifying lap at Monaco's 1988 Grand Prix illustrates the importance of flow perfectly.

> I was already on pole, and I just kept going. Suddenly I was nearly two seconds faster than anybody else, including my team mate with the same car. And suddenly I realised that I was no longer driving the car consciously. I was driving it by a kind of instinct, only it was a different dimension. It was like I was in a tunnel.

[That lap has been described as the greatest lap of Senna's career](http://youtube.com/watch?v=K9QH8-lKEYY).

Flow is a state of complete immersion in an activity, a state where the outside and inside world merge into one and the person is simply _present_. Mihaly Csikszentmihaly - the father of flow research in psychology - describes flow as

> completely focused motivation. A single-minded immersion that represents perhaps the ultimate in harnessing the emotions in service of performing and learning.

In his essay [Holding a program in one's head](http://paulgraham.com/head.html) Paul Graham explains that to be effective, programmers must be able to hold an entire program in their head while they work. It's the only way the problem and its solution can have the plasticity needed to make sweeping changes and improvements.

Because programmers tend to work at the limits of their tolerance for complexity holding a program in one's head is only possible in a state of flow.

But flow is a fragile balance between many opposing forces. The programmer must be willing and able to completely focus on the task at hand, they must have a clear goal to work towards, fresh challenges must be coming in just quickly enough and they must feel a sense of purpose, even joy, in what they're doing.

## The autotelic personality

In his work Csikszentmihalyi describes a type of personality that can experience episodes of flow more easily and more often than most people.

Researching flow in a lab is too difficult to get proper results, but evidence keeps wagging its eyebrows suggestively, hinting at the validity of something called an "autotelic personality".

If there is such a thing, I think programmers generally apply:

 * curious
 * persistent
 * not self-centered
 * often performs activities for intrinsic reasons

It [has been drawn in stick figures](http://xkcd.com/242/) that when a normal person pushes a big button saying "Don't press this" and gets electrocuted, they think to themselves "Heh, I shouldn't have done that." But when an engineer presses that same button they go "Huh, I wonder if that happens every time"

All programmers are engineers at heart, no matter what their formal qualifications might say. 

Relentlessly hunting down bugs is a source of great pride for most programmers and many would sooner go without sleep than allow a bug to remain in production code. More experienced developers will often go to sleep once they realise they've started making silly mistakes, but they will never forget a bug that's taunting them.

Even a casual perusal of Github repositories will show that a lot of programmers indulge in so called pet projects - little programs developed for the fun of it, to sharpen the saw if you will. Interestingly enough, flow is much easier to experience on pet projects than large for-money behemoths.

It could be argued that programmers are very selfless people - the existence of communities like StackOverflow, large numbers of conferences where speakers share their knowledge for free, numerous blogs and free tutorials, not to mention the large opensource community that's given us something as powerful as the Linux operating system and the stack most of the internet runs on. All of those are done holistically ... well, mostly. Everybody gains from having a good standing in the community.

As a group of people, programmers exhibit all the traits of an autotelic personality. This would suggest flow is much more prevalent amongst programmers than in other groups of people, which might also explain why we programmers are often perceived as night walkers.

## Is achieving flow easier at night?

Yes, flow is indeed much easier to achieve in the evening. At least for those of us who manage to think clearly and who still feel relatively rested. For many, the structure of their life makes this impossible - some then approach the night from its other end, others learn to work during the day.

### Decision fatigue

The biggest enemy to evening and night-time productivity is decision fatigue.

Most people experiencing decision fatigue don't recognise it for what it is, but if you've ever felt well rested physically and still couldn't think clearly, like your brain was tired, you've experienced decision fatigue.

[Research](http://www.nytimes.com/2011/08/21/magazine/do-you-suffer-from-decision-fatigue.html) has shown that humans can only accept a limited amount of decisions every day, after that we usually go with the default action, or are so incapable of making a decision we can't perform the action at all.

Not only that, it's been shown that even the tiniest decision factors into the quota - everything from deciding what to eat for breakfast, to which outfit to wear and what websites to read now or later. This is why the checkout aisle in your supermarket is filled with tiny things you otherwise wouldn't have bought and why people instinctively want to "sleep on it" when making big decisions.

Depending on how a programmer's day is structured, working in the evening can be a godsend or a spaghetti code mess producing mistake. The important thing is to be well rested regardless of the time when you start working.

An interesting side-effect of decision fatigue in its early stages is that you can often focus better _because_ you are a bit tired. You know there's no other choice but to power through the work, so you sit down, ignore everything else and just code.

Eventually decision fatigue catches up and you find yourself thinking long and hard about what variable name to choose.

### Clear mind

Flow is marked by an intense, almost meditative, calm. No other thoughts can invade your brain than what pertains to the task at hand. Everything else ceases to exist.

But when things are hanging over your head, so to speak, achieving flow is nearly impossible for most people. The mental clarity and emotional calm just isn't there.

Whether it's an errand you still have to run, or an important email you mustn't forget to send. Perhaps there's just some worrying stuff going on and you aren't Irish enough not to worry about it. Sometimes you simply have an IRC chatroom open in a hidden window. 

If there's something tugging at your brain, you might as well forget about flow.

Perhaps the biggest thing everyone's got tugging on their brain is the anticipation of imminent distraction. You _know_ something is going to happen in an hour or two. Sometimes it's a big meeting, other times you have to be around to take a call - either way, it can be very distracting even if you do know when the distraction is going to happen.

Everyone knows those moments where it's 2:35 and you expect something to happen at 3:00. You try to get work done, but you keep looking at the clock every two minutes. Then you might as well check a tweet or two … when 3:00 rolls around you basically haven't done anything useful for almost half an hour.

Not knowing when, or even if, a distraction is going to happen only makes it worse. You're paying half attention to your code and half attention to your environment at all times. When a colleague sitting across the room says something, you immediately listen in, process what you've heard, decide it wasn't about you and get back to work.

You'd love to tune out completely, but sometimes it _is_ for you and you have to respond. Random rewards are after all the strongest behaviour creator in existence.

Something wonderful happens at night, though. There are no more distractions, at least there is no more threat of imminent distraction. Since everyone is asleep you can be fairly certain nobody is going to give you a call, nobody will ask you a random question, nothing interesting is going to happen on the internet.

For at least ten hours _nothing_ will be expected of you. Nothing. That's a lot of freedom right there.

### Habit

Have you ever had a habitual activity fall through? Say you go to the gym every Wednesday at six in the evening. Or you always watch a certain show on television at exactly 7PM every Thursday.

When something comes up and you can't do what you're used to it doesn't feel like you've gained an extra hour or two. No, you feel lost, like you suddenly don't know what to do with all this extra time you've been given. So you end up wasting it, clicking one more link on Reddit, or flicking through one more channel on the telly.

As they say, habit is an iron shirt. 

Getting used to something takes a concerted effort of a few weeks, but once the habit is built it's almost impossible to change. Just remember how odd it feels when you forget to brush your teeth in the morning!

It's the same thing with flow - it's simply easier at certain times in the day. This depends on a lot of things like how many other obligations you have, what the schedule of the people around you might be and even your internal cycles of activity, which tend to depend a lot on meal times.

But once you get used to working at a certain point in the day, suddenly your other habits start forming around these patterns instead of the other way around. It's a bit of a self-reinforcing pattern you see.

Since most programmers start very young, let's take a young programmer for example. Let's say they're still in high school.

This programmer needs to get up every morning at a predetermined time so they can get to class. They are stuck in class until, say, 3PM. They come home, their mum wants them to do a bunch of chores, there's homework to tend to and before they know it it's already 9PM or 10PM.

And now, finally, there's nothing hanging over their heads anymore. They can get to programming.

In a few years this person has come to college, there's much less external time constraints, but after many years of _starting_ coding in the evening they associate the activity with night-time. They simply can't get their mind to coding before 9PM anymore.

Thus, another night-time hacker is born. With years and piling pressure from the outside, their schedule will shift around, flow to and fro to meet other demands in their lives.

But when shit hits the fan and something _needs to get done_, I bet they will go back to their safe place and code all night.

## Two types of flow and what keeps them going

Once a programmer gets into flow, it is paramount that they stay there for as long as possible. Not only will they get more work done simply because they're spending more time working, flow is a self-fulfilling prophecy. The more time you spend in flow, the easier getting into flow becomes and the deeper the flow becomes.

But not all flow is created equal, sometimes it will leave you energised and awash with even better ideas, other times flow might leave you completely exhausted in the end having just squeezed every last ounce of awesome out of you.

The difference depends mostly on what kept the flow going.

### Panic mode

Every one of us probably knows that feeling of sheer panic that only a hard deadline can bring. The moment you realise The Paper is due next morning, it's already 10pm, you've just come home from an evening of beers and suddenly discovered you _still_ haven't picked up that book from the library. You know, the one with all the info you need to write this thing.

That's when real productivity begins for most people. That's when they can really tell what they're made of.

The outside world melts away as you pound the keyboard in a furious panic. Internet stops existing, Skype going off every five minutes could just as well be a supernova going off in a distant galaxy. Nothing exists but you and your work.

Come morning, you are tired, cranky, effectively two days behind on sleep, but victorious. It might not turn out to be a perfect mark, but it's better than a fail. You know you could have done better if only you had started earlier, but you didn't.

What just happened was a panic induced flow. 

You spent the entire night essentially in a fight or flight response, adrenaline coursing through your veins made you hyped up, focused. But it was also exhausting, your only reward a deadline not missed. The price, half arsed work and the subsequent day completely wasted because you will be too tired to think.

### Deep fulfilment

The converse of panic flow, is the good kind. A drug-like trance that leaves you energised, ready to take on the world and were it not for annoying physical limitations you would happily spend all your days in such a state.

For me the typical situation is something like this.

I have spent the past few days thinking about an interesting problem, it's just been rolling around my mind. Either it's an interesting algorithm I want to try implementing, or a problem I feel could be solved for plenty of people. Sometimes it's as simple as feeling a blogpost must be written to address a topic.

I let the feeling fester for a while. On purpose. Indulging immediately would ruin the flow because the mind must first have time to process the idea in as much detail as possible.

One evening I will sit down and begin.

The outside world melts away, time becomes a blur and before I know it morning comes. Surprising. Startling. When the hell did this happen? Wasn't it just 8pm half an hour ago?

In reality, I have just spent twelve hours in complete rapture. Engrossed in the bigger picture I solved sub problem after sub problem, each just interesting enough to keep me going, each just difficult enough to keep me going.

At this point my body has had enough and I do need to get some sleep.

But the very next day I will jump out of bed - yes literally - and even brushing my teeth might feel like too much waiting to get back into the code.

That's the good kind of flow. The one you want. Because this is sustainable, were it not for practical limitations one could live for months on end like this.

Panic flow … that one is only good for one or two consecutive days. Then it takes weeks before the brain is ready again.


## Why is day-time particularly bad for flow?

Now we can all agree the night is particularly good for flow, it is important to remember this is not the only time when programmers can reach flow. Mornings, especially very early mornings, are a popular choice as well. Even though this is just approaching the night from a different end, the cultural baggage attached is different.

People who start work early in the morning, especially before dawn, are often seen as hard-working and commendable, while those who choose to work late into the night, often right until dawn, are often seen as lazy slobs who sleep the whole day away. Strange as it may seem.

Whether a programmer chooses late nights or early mornings, doesn't really change the goal - to avoid working on high intensity flow activities during the day.

The answer I got when asking programmers why they don't like working during the day sounds very asocial indeed - because other people are awake.

### Cost of interruption

There is a ritual to getting in the flow. 

Usually the first thing people will do when sitting down to code is check Facebook, Twitter and email. Not always in that order, not always all of them, sometimes other social networks completely - Reddit, Hacker News and Stack Overflow are popular options.

Warm caffeinated beverages go very well with this sort of activity. Making them wastes little time, but introduces an impetus to keep procrastinating until you've finished the cup.

We call this procrastination, but the term carries connotations that aren't fully warranted. Don't think of it as putting off work, it's more like defragging one's brain. Making sure there are no more lingering thoughts in there, no notifications left unclicked, no important questions left unanswered.

After anywhere from a few minutes to an hour work can finally begin.

First, a programmer needs to make sure they are working off the latest version of the project. Then they must check whatever issue tracking system they're using. Having a clear goal is after all paramount to achieving flow and getting anything done.

Next up, the work environment.

Swing by a programmer's computer some time and you will likely see a desktop littered with open windows, consoles, IDE's, text editors, documentation. Everything.

Unlike many (most?) people who use even modern computers as a single application environment and often maximise whatever software they are using to fill the whole screen, programmers are a different beast all together.

There's usually a text editor and a console or two, perhaps a debugger, a browser with some documentation is almost mandatory as well. Often all these tools will be unified in a single Integrated Development Environment (IDE), which is a mere euphemism for "A bunch of stuff, but in a single window".

Loading up a work environment like that takes time, not because our computers are slow, but because to know which tools you need, requires understanding what you're about to work on. Keeping things open helps so much that a session crash or a context switch to a different set of tools can be totally devastating to a programmer's productivity.

Then, the programmer must prime their mind.

Programs are a conversation between programmer and computer. Computer and user. The programmer's job is breaking down a problem into understandable bits and explaining the solution to the computer in such a way it can be executed perfectly every time. Or at least well enough.

Loading a program into your brain means learning its language. Functions are verbs, variables are nouns and there's plenty of things in between. Notes can help. Keeping tools open also helps. But nothing will get you over just how much brain power it takes to understand a software project.

Every time you lose sight of the whole system you have to build it again like constructing a glass palace. Once you understand the language, you have to arrange it in your mind so the space can be freely traversed, you can close your eyes and _see_ how different parts of the system affect each other.

Only after this stage has been reached is a programmer fully effective. Only then can they have any chance of reaching flow because they don't have to stop every five minutes to figure out how their code fits in the larger picture and whether it's even doing what it's supposed to.

When you interrupt a programmer, this glass palace can come crashing down in a shower of shattered glass. They have to start the whole process all over again and it's going to take a while before they're back to full steam.

### Distractions

Not all distractions are created equal and not all will cause an interrupt

You will often see a programmer walking along the street, eyebrow furrowed, peering into the tips of their shoes, lips clenched. Do _not_ try talking to them. This is a programmer who is deep in thought on a problem, struggling hard to prevent the glass palace from tumbling.

Ask them a question and it can all be gone in the blink of the eye. All that hard work and deep concentration, just gone. Simply because they have to think about something else.

It almost doesn't matter how simple a question you're asking, anything requiring a proper answer will cause a lot of trouble. Most programmers tend to resort to communicating with grunts and various sounds. Or simply saying "Yeah yeah sure" to everything.

The danger is not knowing they weren't really listening to you and just said something so you'd go away and stop bothering them. Flailing hands and raised voices can also happen.

Almost more important than whether the programmer had to do some thinking in response to a distraction is whether they chose to be distracted or it was something outside their control.

Most people working with computers will often distract themselves. After being focused for a while they will start wasting time on the internet. Nobody told them to do this, often there isn't even a notification saying something new happened, it just feels like "Hey, I haven't done that in a while! I should check if there's anything new!" … there usually isn't. Not much anyway.

I'm lying, there's always _something_ new. But it usually isn't interesting or something that feels worth the distraction.

However, random rewards keep us hooked and we can't help ourselves but to check, pressing the button like a lab rat desperately trying to get the next nugget of food from the magical big button. 

If a programmer can prevent themselves from straying off into the wild internet and getting lost for an hour, this sort of distraction won't cause much of a problem. In just a few minutes they will be back to coding at full blast. These sort of distractions are usually just our brain saying we should take a break anyway.

Conversely even the shortest external distraction can be devastating.

Most distractions come from coworkers who are just trying to get their work done, but need your involvement - the gordian knot of working in a team of programmers is having two programmers who depend on one another. Both are in a state of flow. One of them has a problem. Do they destroy their productivity by waiting on the other person to naturally come out of flow, or destroy the other person's productivity by interrupting them?

Hopefully they can work on something else, but this requires a context switch to a different problem as well.

Programmers also run on a different schedule than most people, which can cause plenty of problems. When the cost of getting started is as high as it is for programmers, it doesn't make sense to work in stretches shorter than a few hours. Everyone else divides their time by hours or even half hours. I've heard lawyers charge in increments of fifteen minutes.

Even the prototypical calendar app divides the day into hours and half hours ...

If there's one thing you should know about dealing with programmers is **do not distract them**. Wait for _them_ to come to _you_. Just put your request in the queue.

Never expect a programmer to do something immediately.

## Why programmers work at night

There's magic in the night-time. The peace and quiet, the internal serenity … There's just you, your work and an infinite abundance of time. You are alone.

As a society we know that smart, talented people work at night. Often in solitude, they solve problems mere mortals could only dream of. Look no further than your nearest book, movie or TV show about a lone genius ...

He is a youngish man. A bit of a loner. Doesn't get along with people terribly well. Likes to work at night or before dawn.

The stereotypical programmer is a friendlier version of that: likes staying up all night, lives off coffee and energy drinks, makes loud noises when disturbed, occasionally writes mean things on the internet.

### Culture

There is a lot to be said about the effect of culture on when people work. Especially when your idea of hard work is sitting behind a computer all day and doing tiny repetitive motions with your fingers.

One of the greatest benefits of being a programmer is that you can work whenever your mind feels at its best and most productive. You might often have to adjust to other team members either for collaboration or with the explicit purpose of avoiding unwanted interruption, but generally speaking, when you work depends on your personal preference alone.

A lot of professions can't afford this luxury - journalists have daily deadlines, sales people have to catch people in certain moods, farmers must feed animals at specific times and so on.

But it wasn't always like that.

One of the programmers I spoke to while researching this book had the pleasure of working on old mainframe systems a few decades ago. Back then, computing power was a scarce resource and carefully managed. To run a program on a mainframe you needed access. That access was much easier to get at night when other parts of your organisation weren't using the mainframe to do whatever.

So programmers preferred to stay up late rather than work during the day, IT was simply easier to get the computing resources they needed.

In the late 1980's and early 1990's computers became commoditised and everyone could have access right from their bedroom. But at the same time the internet came into wider use, amongst programmers especially.

I was lucky enough never to endure dial-up internet. Right around the time internet access was becoming ubiquitous so was ADSL; I managed to convince my parents "broadband" would be cheaper than internet phone bills. But I still remember a computer enthusiastic family friend explaining his internet strategy when I was about 7 years old.

> You see, internet use is very limited during the day. Somebody might call your house and your line will be busy. Or your parents will want to use the phone or something. Then in the evening everybody suddenly wants to connect and the internet becomes clogged up, really slow.

> So your best bet for the internet is after 10pm or 11pm, that's when you can reach full speed. Another option is at 6am or 7am, but that's really hard to get up for.

I was very impressed by all of this, didn't understand a thing and stuck to windows3.1 games on his computer. Those were fun. The internet did not sound like an interesting place at all.

A combination of these factors may have greatly contributed to the idea that "computer people" work at night. That they live off coffee and are generally night dwellers who avoid light at all cost. 

Of course programmers aren't doing anything to fight this notion - habitual bragging about how resilient you are to sleep and how you managed to stay up all night to fix a bug is widespread.

Remember, programmers work at night. Would a young upstart really dare call themselves a real programmer if they didn't enjoy working at night? Of course not. Plus there's all those movies saying that smart people work at night … and you want to be smart, right?

### The science of night owls

A growing body of research gives credence these ideas. People with higher general intelligence are likelier to prefer staying up late and people _are_ more creative in the evening than in the morning.

[A study published in 2006](http://www.sciencedirect.com/science/article/pii/S0191886999000549) studied USAF trainees in the sixth week of their training. The important part being that as a result of their training, all participants in the study lived the same lifestyle, ate the same food etc. Factors, which have been shown to affect circadian rhythms.

The study found that people who self-identified as preferring the evening also achieved higher scores in the different cognitive tests measuring things like memory and processing speed. Albeit the correlation was small, it was consistent. 

Interestingly enough, individuals self-identifying as evening types, achieved higher scores in the morning as well. This is despite the USAF population being skewed towards morningness.

The study also mentions all other morningness-eveningness research would indicate a link between higher general intelligence and a preference for night owl behaviour. Arguing that the sample populations in those studies exhibited a skew towards eveningness and because they were done on university students, who generally have higher intelligence, this would indicate a positive link between the two.

The research I've found on this topic does not say much about whether being smarter means you will prefer evenings, or preferring evenings means you will be smarter.

[Another relevant study](http://www.tandfonline.com/doi/abs/10.1080/13546783.2011.625663) from 2011 looked at the difference in solving insight and analytic problems based on morningness-eveningness preference and when you are actually solving the problem.

Their findings indicate that people perform better at insight-based tasks when they are not at their best time. So a night owl is more creative in the morning, while a lark is more creative in the evening. One of the given explanations supported by a related experiment was that being tired inhibits ones ability to focus, which in turn makes you more capable of thinking widely, beyond the scope of already retrieved knowledge.

As expected, solving analytical problems shows a positive correlation between time preference and when you're actually solving a problem. Night owls perform better in the evening, larks in the morning. This is very likely due to the fact that peak activity time relates to when we are best able to focus.

All of this goes somewhat against two of the original hypotheses I proposed before writing this book - that of being more creative in the evening would only appear to be true for morning people, but it seems odd that programmers would habitually work in the evening if they were morning people. Especially since neutral people without a preference do not exhibit creativity gains depending on time of day.

The other hypothesis that finds itself on shaky ground is the idea that we better manage to focus when tired because a processing power limit is reached and we have no other choice but to focus lest no work get done at all. I will explore this further in the Sleep Science section of the book.

### Flow

> To do high, real good physics work you do need absolutely solid lengths of time, so that when you’re putting ideas together which are vague and hard to remember /../ it needs a lot of concentration

  ~ Richard Feynman, The Pleasure of Finding Things Out

Just like Feynman's physics example, programming is a process requiring deep thought and a lot of concentration. It's abstractions all the way down. The only way to do good programming is to become completely immersed, so focused you might forget to eat drink and sleep.

You need flow.

> Flow is the mental state of operation in which a person performing an activity is fully immersed in a feeling of energised focus, full involvement, and enjoyment in the process of the activity.

Flow was discovered in 1975 by Mihaly Csikszentmihalyi while he was observing artists who got so lost in their work they would forget to eat and drink and would even stop noticing the passage of time.

Flow is the natural state of the programmer.

Any programmer will tell you stories of the wonderful work they've done while in flow, in the zone, wired in or any of a number of euphemisms that all mean the same thing - the programmer had an interesting task, it was challenging, but not too much, and they were left alone to work.

A lot, if not most, of creative professions experience flow, but it's especially important for programmers. The systems we work on have become so complex they are impossible for an individual to understand fully.

It's like building a house of cards where every card is slightly bent and torn. You have to balance them carefully, keep all of them in mind when adding a new card and should a single card falter, everything will come tumbling down.

When a programmer works their brain is playing this delicate game of card house building. Unless fully immersed, the going will be tough, if not impossible.

More importantly, the work we do provides everything necessary to achieve flow:

 * challenging
 * offers immediate feedback
 * clear objectives
 * never really ends

It's very easy to get sucked into a programming task. You build the framework in your mind, start working, constantly receive feedback from the computer, make tweaks, beat one small problem after another until suddenly it's morning and birds are chirping outside the window. You're feeling slightly tired, quite hungry, a bit thirsty and confused as to where all the time has vanished off to.

Right now, if you've ever experienced flow, you are nodding in understanding. If not, you think I'm crazy and am talking complete nonsense. How could you not notice when you get hungry or tired!? Silly person.

Surely  you've played a video game before?

Video games are specifically designed to get players into a state of flow. To make them fully concentrated on the gaming experience and forget the world around them. The learning curve is always just steep enough to be interesting, the challenges are non-repetitive and you're having fun.

This is why we hear unfortunate stories of people forgetting to feed their children or starving themselves to death while playing.

Now imagine your job looked like that. A never-ending string of challenges you can solve with the tiniest bits of focused thinking.

### Shifting sleep schedules

Of course you _could_ code before 3pm, a lot of people do. You likely wouldn't lose a bet saying most employed programmers spend a lot of time at work before 3pm.

But without an external schedule coding at night just feels more natural. It's when the fun stuff happens.

You still need to sleep, though. What happens when you go to bed at two in the morning? You wake up at ten in the morning, perhaps nine. If you're really hardcore even at eight.

Come evening, you don't feel sleepy until midnight. You're just working on something interesting, so you keep working until 1am. Or slightly later.

Eventually your sleep cycle shifts into a different timezone because you keep going to bed later and later, because you've woken up much later and so on ad infinitum until your alarm clock and society pressure put you in an equilibrium of sorts.

For a lot of people that equilibrium seems to be waking up at 11am and going to bed at 3am. I don't know why.


### Bright screens

One of the biggest factors in human sleep-wake cycle is natural light. Scientists have shown that without external stimuli we would all be living on a roughly 26 hour cycle, but there are systems in our bodies that help us sync with the sun.

This is very important because days aren't equally long and before artificial lighting it wouldn't be very useful to stay awake for the same time in winter days as in summer days. Doesn't make sense and you need to conserve energy when it's cold anyway.

Modern lighting plays foul with those principles. Computer screens especially.

This is because the light coming off our screens is very white, aimed right at our eyes and usually insanely bright because monitors are set to stupid brightness levels by default and most people forget to change those.

All of this just plays back into the not-becoming-sleepy problem and keeps us up longer. Because we aren't sleepy, we might as well work huh?
